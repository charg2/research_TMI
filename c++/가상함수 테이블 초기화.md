# 가상함수 테이블 초기화.

가상함수 테이블이 쓰이는 시점.
각 생성자를 부르는 시기.

1.부모 생성자 호출시 가상함수 테이블에 부모 객체의 가상함수 테이블을 기입.
2.자식 생성자 호출시 가상함수 테이블에 자식 객체의 가상 함수 테이블을 기입.

1번 부터 보자.

![%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%86%AF%20%E1%84%8E%E1%85%A9%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%206c51949c311f4790a79abe7850db68ee/Untitled.png](vftable/Untitled.png)

부모인 A객체의 생성자를 들어가자 마자 __vfptr 가상함수 테이블이 갱신되었다. ( 물론 이전에는 쓰레기값 ) 
그렇다는것은 A 생성자가 호출되면서 값이 갱신되었다는건데 당연히 코드로는 안나와 있으니 어셈블리를 보자.

![%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%86%AF%20%E1%84%8E%E1%85%A9%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%206c51949c311f4790a79abe7850db68ee/Untitled%201.png](vftable/Untitled%201.png)

A생성자 호출 이후 모습인데. 
스택 세팅, this 세팅,
lea rcx, [A::'vftable' (07FF6D09B3408h)] 
rcx에 가ㅏㅇ함수 테이블 값을 넣고.
rcx를 rax즉 this의 메모리위치에 넣었다.
이때 부모의 생성자를 넣었다.

2. 

![%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%86%AF%20%E1%84%8E%E1%85%A9%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%206c51949c311f4790a79abe7850db68ee/Untitled%202.png](vftable/Untitled%202.png)

위의 사례에서 당연하게 B를 호출하면서 B의 가상함수 테이블 삽입.

어셈블리 봐도 명확하다.

![%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%86%AF%20%E1%84%8E%E1%85%A9%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%206c51949c311f4790a79abe7850db68ee/Untitled%203.png](vftable/Untitled%203.png)

# 번외 테스트.

가상함수 테이블 부모껄로 변경시 부모껄로 호출하나 

B의 가상함수 테이블인 상태.

![%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%86%AF%20%E1%84%8E%E1%85%A9%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%206c51949c311f4790a79abe7850db68ee/Untitled%204.png](vftable/Untitled%204.png)

위의 나와 있는 0x00007ff6d09b3408로 변경시

![%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%86%AF%20%E1%84%8E%E1%85%A9%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%206c51949c311f4790a79abe7850db68ee/Untitled%205.png](vftable/Untitled%205.png)

A의 가상함수 테이블로 변경.

 A값으로 호출.  B소멸자도 호출이 안되고 끝난다.

![%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%20%E1%84%90%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%87%E1%85%B3%E1%86%AF%20%E1%84%8E%E1%85%A9%E1%84%80%E1%85%B5%E1%84%92%E1%85%AA%206c51949c311f4790a79abe7850db68ee/Untitled%206.png](vftable/Untitled%206.png)

## 테스트 코드

```cpp
#include <iostream>

using namespace std;

struct A
{
    A()
    {
        cout << "A 생성 : " << (void*)this << endl;
    }

    virtual ~A()
    {
        cout << "A 소멸 : " << (void*)this << endl;
    }

    virtual void test()
    {
        cout << "A 테스트 : " << (void*)this << endl;

        return;
    }

    bool a;
    int n[100];
};

struct B : A
{
    B()
    {
        cout << "B 생성 : " << (void*)this << endl;
    }

    virtual ~B()
    {
        cout << "B 소멸 : " << (void*)this << endl;
    }
    
    virtual void test() final
    {
        cout << "B 테스트 : " << (void*)this << endl;

        return;
    }
};

void main()
{
    A* a = new B;
    a->test();
    delete a;
}
```